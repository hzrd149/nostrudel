import { kinds, matchFilters } from "nostr-tools";
import { WriteQueue } from "../cache/write-queue.js";
import { IndexCache } from "../cache/index-cache.js";
import { getEventsForFilters, countEventsForFilters, } from "../database/query-filter.js";
import { sortByDate } from "../utils.js";
import { nanoid } from "../lib/nanoid.js";
import { logger } from "../debug.js";
import { getEventUID } from "../database/ingest.js";
import { pruneLastUsed } from "../database/prune.js";
const defaultOptions = {
    batchWrite: 1000,
    writeInterval: 100,
    cacheIndexes: 1000,
    pruneInterval: 1000 * 60,
    maxEvents: 10000,
};
const log = logger.extend("relay");
/** Main class that implements the relay logic */
export class RelayCore {
    options;
    writeInterval;
    pruneInterval;
    get running() {
        return !!this.writeInterval;
    }
    eventMap = new Map();
    writeQueue;
    indexCache;
    db;
    baseEoseTimeout = 4400;
    subscriptions = new Map();
    constructor(db, opts = {}) {
        this.db = db;
        this.options = { ...defaultOptions, ...opts };
        this.writeQueue = new WriteQueue(db);
        this.indexCache = new IndexCache();
        this.indexCache.max = this.options.cacheIndexes;
    }
    async start() {
        log("Starting");
        this.writeInterval = self.setInterval(() => {
            this.writeQueue.flush(this.options.batchWrite);
        }, this.options.writeInterval);
        this.pruneInterval = self.setInterval(() => {
            pruneLastUsed(this.db, this.options.maxEvents);
        }, this.options.pruneInterval);
    }
    async stop() {
        if (this.writeInterval) {
            self.clearInterval(this.writeInterval);
            this.writeInterval = undefined;
        }
        if (this.pruneInterval) {
            self.clearInterval(this.pruneInterval);
            this.pruneInterval = undefined;
        }
        log("Stopped");
    }
    async publish(event) {
        if (!kinds.isEphemeralKind(event.kind)) {
            this.writeQueue.addEvent(event);
            this.indexCache.addEventToIndexes(event);
        }
        const uid = getEventUID(event);
        let subs = 0;
        if (!this.eventMap.has(uid)) {
            if (!kinds.isEphemeralKind(event.kind))
                this.eventMap.set(uid, event);
            for (const [id, sub] of this.subscriptions) {
                if (sub.onevent && matchFilters(sub.filters, event)) {
                    sub.onevent(event);
                    subs++;
                }
            }
        }
        return `Sent to ${subs} subscriptions`;
    }
    async count(filters) {
        return await countEventsForFilters(this.db, filters);
    }
    addToEventMaps(events) {
        for (const event of events)
            this.eventMap.set(getEventUID(event), event);
    }
    async executeSubscription(sub) {
        const start = new Date().valueOf();
        log(`Running ${sub.id}`, sub.filters);
        // load any events from the write queue
        const eventsFromQueue = this.writeQueue.matchPending(sub.filters);
        return new Promise((res, rej) => {
            const timeout = setTimeout(() => {
                if (sub.oneose)
                    sub.oneose();
                res();
            }, this.baseEoseTimeout);
            // get events
            getEventsForFilters(this.db, sub.filters, this.indexCache, this.eventMap).then((filterEvents) => {
                clearTimeout(timeout);
                this.addToEventMaps(filterEvents);
                if (sub.onevent) {
                    const idsFromQueue = new Set(eventsFromQueue.map((e) => e.id));
                    const events = eventsFromQueue.length > 0
                        ? [
                            ...filterEvents.filter((e) => !idsFromQueue.has(e.id)),
                            ...eventsFromQueue,
                        ].sort(sortByDate)
                        : filterEvents;
                    for (const event of events) {
                        try {
                            sub.onevent(event);
                            this.writeQueue.useEvent(event);
                        }
                        catch (error) {
                            log(`onevent failed with error`, error);
                        }
                    }
                    const delta = new Date().valueOf() - start;
                    log(`Finished ${sub.id} took ${delta}ms and got ${events.length} events`);
                }
                if (sub.oneose)
                    sub.oneose();
                res();
            });
        });
    }
    subscribe(filters, options) {
        // remove any duplicate subscriptions
        if (options.id && this.subscriptions.has(options.id)) {
            this.subscriptions.delete(options.id);
        }
        const id = options.id || nanoid();
        const sub = {
            id,
            filters,
            close: () => this.subscriptions.delete(id),
            fire: () => this.executeSubscription(sub),
            ...options,
        };
        this.subscriptions.set(id, sub);
        this.executeSubscription(sub);
        return sub;
    }
    unsubscribe(id) {
        const sub = this.subscriptions.get(id);
        if (sub) {
            log(`Closing ${id}`);
            sub.onclose?.("unsubscribe");
            this.subscriptions.delete(id);
        }
    }
}
