import { BlossomClient, } from "blossom-client-sdk";
import { base64 } from "@scure/base";
import { Drive, getEmptyMetadata } from "./Drive.js";
import { decrypt, encrypt } from "./crypto.js";
import { TreeFolder } from "./FileTree/TreeFolder.js";
export const ENCRYPTED_DRIVE_KIND = 30564;
export const DEFAULT_SCRYPT_LOGN = 10;
const drivePasswords = new WeakMap();
export class EncryptedDrive extends Drive {
    constructor() {
        super(...arguments);
        this.encoder = new TextEncoder();
        this.decoder = new TextDecoder();
        this.logn = DEFAULT_SCRYPT_LOGN;
        this.locked = true;
    }
    /**
     * Attempts to decrypt the drive with the provided password
     * If successful it will set locked=false and save the password in memory
     */
    async unlock(password) {
        if (!this.event)
            throw new Error("No Event");
        if (!this.locked)
            throw new Error("Already unlocked");
        try {
            drivePasswords.set(this, password);
            this.locked = false;
            await this.resetFromEvent();
        }
        catch (e) {
            drivePasswords.delete(this);
            this.locked = true;
            throw e;
        }
    }
    lock() {
        if (!this.locked) {
            drivePasswords.delete(this);
            this.locked = false;
            this._metadata = getEmptyMetadata();
            this.tree = new TreeFolder("");
        }
    }
    /** Used to set the password on new drives */
    setPassword(password, logn = DEFAULT_SCRYPT_LOGN) {
        if (this.locked && !drivePasswords.has(this)) {
            drivePasswords.set(this, password);
            this.logn = logn;
        }
    }
    readEvent(event) {
        const password = drivePasswords.get(this);
        if (!password)
            throw new Error("No password provided");
        const data = decrypt(base64.decode(event.content), password);
        const plaintext = this.decoder.decode(data);
        const tags = JSON.parse(plaintext);
        this.locked = false;
        return super.readEvent({ ...event, content: "", tags, created_at: 0 });
    }
    createEventTemplate() {
        const password = drivePasswords.get(this);
        if (!password)
            throw new Error("No password set");
        const template = super.createEventTemplate();
        const plaintext = this.encoder.encode(JSON.stringify(template.tags));
        const data = encrypt(plaintext, password, this.logn);
        const ciphertext = base64.encode(data);
        template.kind = ENCRYPTED_DRIVE_KIND;
        template.content = ciphertext;
        // only keep the "d" and "scrypt-logn" tags public
        template.tags = template.tags.filter((t) => t[0] === "d");
        template.tags.push(["scrypt-logn", String(this.logn)]);
        return template;
    }
    update(event) {
        if (!this.locked)
            return super.update(event);
        else if (!this.event || event.created_at > this.event.created_at) {
            this.event = event;
            this._metadata.identifier =
                event.tags.find((t) => t[0] === "d")?.[1] ?? "";
            const logn = parseInt(event.tags.find((t) => t[0] === "scrypt-logn")?.[1] ?? "");
            if (Number.isFinite(logn) && logn > 0 && logn <= 22)
                this.logn = logn;
            else
                this.logn = DEFAULT_SCRYPT_LOGN;
            // @ts-expect-error
            if (Object.hasOwn(event, "pubkey"))
                this._metadata.pubkey = event.pubkey;
            return true;
        }
        return false;
    }
    /** Encrypt a Blob with the drives password */
    async encryptBlob(blob) {
        if (this.locked)
            throw new Error("Drive locked");
        const password = drivePasswords.get(this);
        if (!password)
            throw new Error("No password provided");
        const buffer = await blob.arrayBuffer();
        const ciphertext = encrypt(new Uint8Array(buffer), password, this.logn);
        return new Blob([ciphertext], { type: "application/octet-stream" });
    }
    /** Decrypt a Blob with the drives password */
    async decryptBlob(blob, type) {
        if (this.locked)
            throw new Error("Drive locked");
        const password = drivePasswords.get(this);
        if (!password)
            throw new Error("No password provided");
        const buffer = await blob.arrayBuffer();
        const plaintext = decrypt(new Uint8Array(buffer), password);
        return new Blob([plaintext], { type });
    }
    /** Download and Decrypt a file at the provided path */
    async downloadFile(path, additionalServers = []) {
        if (this.locked)
            throw new Error("Drive locked");
        const password = drivePasswords.get(this);
        if (!password)
            throw new Error("No password provided");
        const file = this.getFile(path);
        const servers = [...this.servers];
        for (const server of additionalServers) {
            if (!servers.includes(server))
                servers.push(server);
        }
        for (const server of servers) {
            try {
                const data = await BlossomClient.getBlob(server, file.sha256);
                const blob = await this.decryptBlob(data);
                return new File([blob], file.name, { type: file.type });
            }
            catch (e) { }
        }
        return null;
    }
}
